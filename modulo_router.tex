\section*{Modulo \nombretad{Router}}

\vspace{22pt}

%INTERFAZ	
\subsection*{Interfaz}
\hspace{-0.75cm}
\textbf{interfaz} \textit{Router}\\
\textbf{se explica con la especificaci\'on de} \textit{router}\\
\textbf{usa interfaces} \nombretad{Bool}, \nombretad{Nat}, 		\nombretad{Conjunto($\alpha$)}, \nombretad{Secuencia($\alpha$)}\\
\textbf{genero} \textit{router}\\
\textbf{operaciones}


%REPRESENTACION
\subsection*{Representaci\'on}
\hspace{-0.75cm}
\textit{enrutador} \textbf{se representa con} \textit{estr}\\
\textbf{donde} \textit{estr} \textbf{es} \textit{tupla$ \\ \langle$\ \\ \textbf{versiones:} nat\ 	$\times$\  \\ \textbf{eventos:} secu(evento)\ $\times$\ \\ \textbf{reglas:} secu(regla)\ $\times$\ \\ \textbf{tiempoCaida:} dicc(interfaz,nat)\ $\times$\ \\ \textbf{estaCaida:} dicc(interfaz,bool) \\ $\rangle$}


%INVARIANTE DE REPRESENTACION
\subsection*{Invariante\ de \ Representaci\'on}

\textbf{\func{Rep}{estr}{bool}{}} 
\hspace{-0.75cm}($\forall$ e:estr)Rep(e)=\\
%sobre versiones:
versionesReglasEnVersiones(e)\\
%sobre Interfaces:
$\wedge$ interfacesDeEventosCorrectas(e)\\
$\wedge$ interfacesDeReglasCorrectas(e)\\
$\wedge$ interfacesCaidaYTiempoCorrectas(e) \\
%sobre eventos
$\wedge$ ordenadosPorTimestamp(e.eventos)\\
$\wedge$ eventosValidos(?)\\
$\wedge$ tiempoCaidaCorrecto(e)  \\
%sobre reglas:
$\wedge$ dirIpDeReglaValida(e.reglas)\\
$\wedge$ cantBitsValida(e.reglas)\\

\newpage

\textbf{funciones Utilizadas:} 

\alinearaxiomas{interfacesCaidaYTiempoCorrectas(e)}

\textbf{\func{versionesReglasEnVersiones}{estr}{bool}{}}
\axioma{versionesReglasEnVersiones(e)}{($\forall$ r:regla)esta?(r,e.reglas) $\impluego$ version(dirIp(r)) $\in$ e.versiones}


\textbf{\func{tiempoCaidaCorrecto}{estr}{bool}{}}
\axioma{tiempoCaidaCorrecto(e)}{($\forall$ i:interfaz)( i $\in$ claves(e.tiempoCaida) $\impluego$
\hspace{10pt} obtener(i,e.tiempoCaida) = sumarTiempo(i,filtrarPorInterfaz(i,e.eventos)))}

\textbf{\func{interfacesCaidaYTiempoCorrectas}{estr}{bool}{}}
\axioma{interfacesCaidaYTiempoCorrectas(e)}{(($\forall$ i:interfaz) i $\in$ claves(e.tiempoCaida) $\vee$ i $\in$ claves(e.estaCaida?)   $\impluego$ i $<$ e.cantInterfaces)}

\textbf{\func{interfacesDeReglasCorrectas}{estr}{bool}{}}
\axioma{interfacesDeReglasCorrectas(e)}{($\forall$ r:regla) esta?(r,e.reglas) $\impluego$ inter(r) $<$ e.cantInterfaces}

\textbf{\func{interfacesDeEventosCorrectas}{estr}{bool}{}}
\axioma{interfacesDeEventosCorrectas(e)}{($\forall$ ev:evento) esta?(ev,e.eventos) $\impluego$ inter(ev) $<$} e.cantInterfaces



\textbf{\func{dirIpDeReglaValida}{secu(regla),conj(version)}{bool}{}}
\axioma{dirIpDeReglaValida(s,cv)}{if vacia?(s) then true \\
								  else dirIP(prim(s)) $\in$ cv $\wedge$ dirIpDeReglaValida(fin(s),c)}

\textbf{\func{ordenadosPorTimestamp}{secu(evento)}{bool}{}}
\axioma{ordenadosPorTimestamp(sev)}{if long(sev) $\leq$ 1 then true\\
									else timestamp(prim(sev)) $<$ timestamp(prim(fin(sev))) \\
									$\wedge$ ordenadosPorTimestamp(fin(sev))}

\textbf{\func{eventosValidos}{secu(evento),dicc(interfaz,bool),nat}{bool}{}}
\axioma{eventosValidos(sev,d,n)}{if n=0? then seCayo?(n,sev) $=$ obtener(n,d) \\
								 else seCayo?(n,sev) $=$ obtener(n,d) $\wedge$ \\
								 eventosValidos(sev,d,n-1)}

\textbf{\func{seCayo?}{nat,secu(evento)}{bool}{}}
\axioma{seCayo?(n,sev)}{if vacia?(sev) then false \\
						else if inter(ult(sev)) $=$ n then caida?(ult(sev)) \\
						else seCayo?(n,com(sev))}

\textbf{\func{cantBitsValida}{secu(regla)}{bool}{}						}
\axioma{cantBitsValida(s)}{if vacia?(s) then true \\
						   else cantBits(prim(s)) $\leq$ 8 * version(prim(s)) \\
						   $\wedge$\ cantBitsValida(fin(s))}


\axioma{filtrarPorInterfaz(i,s)}{
\LIF { vacia?(s)} \LTHEN{ $<>$} 
\\ \LELSE{  
\LIF{ i = inter(prim(s)} 
\LTHEN{ prim(s) $\puntito$ filtrarPorInterfaz(i,fin(s))} \\ 
\LELSE{ filtrarPorInterfaz(i,fin(s))}} \LFI
}

\axioma{sumarCaidas(i,s)}{
\LIF { vacia?(s) $\oluego$ vacia?(fin(s))} \LTHEN{ 0} 
\\ \LELSE{  
\LIF{caida?(fin(s) } 
\LTHEN{ timestamp(prim(fin(s))) - timestamp(prim(s))} \\ 
\LELSE{ 0}} \LFI + sumarCaidas(fin(s))
}
%FUNCION DE ABSTRACCION
\subsection*{Funci\'on\ de\ Abstracci\'on}
\alinearfuncs{Abs}{\hspace{1cm}}
\func{Abs}{estr/e}{enrutador}{Rep(e)}
\vspace{11pt}
($\forall$ e: estr) Abs(e) = r: router/ ((versiones(r) $\igobs$\ $\widehat{e.versiones}$) $\wedge$ (interfaces(r) $\igobs$ $\widehat{e.interfaces}$) $\wedge$ ($\forall$ i: interfaz) (eventos(r,i) $\igobs$ filtrarEventos(i,$\widehat{e.eventos}$)) $\yluego$ (($\forall$ d:dirIp) (enrutar(r,d) $\igobs$ aplicarRegla($\widehat{e.reglas}$,$\widehat{e.versiones}$,$\widehat{e.estaCaida}$,d)))

\vspace{33pt}
\textbf{funciones auxiliares}
\alinearfuncs{salidaPorInterfaz}{\hspace{10.6cm}}

\func{filtrarEventos}{interfaz,secu(evento)/s}{secu(evento)}{ordenadosPorTimestamp(s)}

\func{aplicarRegla}{secu(regla)/s,conj(version)/v,dicc(interfaz,bool),dirIP}{respuestaDir}{($\forall$ r: regla)(esta?(r,s)) $\impluego$ (version(dirIP(r)) $\in$ v)}

\func{hayRegla}{secu(regla),dirIP}{bool}{}

\func{salidaPorInterfaz}{secu(regla)/s,dirIP/s}{interfaz}{($\exists$ r:regla)(esta?(r,s)\ $\wedge$\ (version(dirIP) = version(r))}

\vspace{22pt}
\alinearaxiomas{salidaPorInterfaz(s,u)}
\axiomas{($\forall$ i: interfaz)($\forall$ sev:secu(evento))($\forall$ s: secu(regla))($\forall$ c: conj(evento))($\forall$ d: dicc(interfaz,bool))($\forall$ u: dirIP)}

\axioma{filtrarEventos(i,sev)}{ if\ vacia?(sev)\ then\ $\secuvacia$\\
else\ if\ (inter(prim(sev)) = i)\ then\\ \hspace*{1cm}filtrarEventos(i,fin(sev)) $\circulito$ prim(sev)\\ else\ filtrarEventos(i,fin(sev))\\fi}

\axioma{aplicarRegla(s,c,d,u)}{ if\ (version(d) $\notin$ c)\ then\\DireccionNoSoportada\\
else\ if\ ($\neg$ hayRegla(s,u))\ then\\ \hspace*{1cm}interfazDeSalidaNoEncontrada\\ else\ if\ obtener(salePorInterfaz(s,u),c)\ then\\ \hspace*{1cm}interfazDeSalidaCaida\\ else\ SalidaPorInterfaz(salePorInterfaz(s,u))\\fi}

\axioma{hayRegla(s,u)}{ if\ vacia?(s)\ then\ false\\ else\ primerosBitsIguales(dirIP(prim(s),u,cantBits(prim(s)))\\ \hspace*{1cm} $\oluego$ hayRegla(fin(s),d))\\fi}

\axioma{salidaPorInterfaz(s,u)}{ if\ vacia?(fin(s))\ then\ inter(prim(s))\\ else\ if\ primerosBitsIguales(dirIP(prim(s)),u,cantBits(prim(s)))\ then\\ \hspace*{1cm}inter(prim(s))\\ else\ salePorInterfaz(fin(s),u)\\fi}


%ALGORITMOS
\subsection*{Algoritmos}