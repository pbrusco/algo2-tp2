\section*{Modulo \nombretad{Router}}

\vspace{22pt}

%INTERFAZ	
\subsection*{Interfaz}
\textbf{interfaz} \textit{Router}\\
\textbf{se explica con la especificaci\'on de} \textit{router}\\
\textbf{usa interfaces} \nombretad{Bool}, \nombretad{Nat}, 		\nombretad{Conjunto($\alpha$)}, \nombretad{Secuencia($\alpha$)}\\
\textbf{genero} \textit{router}\\
\textbf{operaciones}

%REPRESENTACION
\subsection*{Representaci\'on}
\textit{enrutador} \textbf{se representa con} \textit{estr}\\
\textbf{donde} \textit{estr} \textbf{es} \textit{tupla$\langle$\ versiones: nat\ 	$\times$\ eventos: secu(evento)\ $\times$\ reglas: secu(regla)\ $\times$\ tiempoCaida: dicc(interfaz,nat)\ $\times$\ estaCaida: dicc(interfaz,bool)$\rangle$}

%INVARIANTE DE REPRESENTACION
\subsection*{Invariante\ de \ Representaci\'on}
\func{Rep}{estr}{bool}{}
\vspace{11pt}

\vspace{33pt}
\otrasops

\alinearfuncs{tiempoCaidaConInterValida}{\hspace{7.5cm}}
\alinearaxiomas{tiempoCaidaConInterValida(dn,n)}
``Todas las versiones de las dirIP de las reglas tienen que pertenecer al conjunto de versiones del router''
\func{dirIpDeReglaValida}{secu(regla),conj(version)}{bool}{}

``Los eventos estan ordenados por timestamp''
\func{ordenadosPorTimestamp}{secu(evento)}{bool}{}

``Los eventos se condicen con estaCaida?''
\func{eventosValidos}{secu(evento),dicc(interfaz,bool),nat}{bool}{}
\func{seCayo?}{nat,secu(evento)}{bool}{}

``El valor de CantBits de una regla no es mayor a 8 veces el valor de la version de la dirIp de la misma''
\func{cantBitsValida}{secu(regla)}{bool}{}

``La cantidad de claves de tiempoCaida es igual a la cantidad de interfaces''
\func{tiempoCaidaConInterValida}{dicc(inter,nat),nat}{bool}{}

``La cantidad de claves de estaCaida? es igual a la cantidad de interfaces''
\func{estaCaidaConInterValidas}{dicc(interfaz,bool),nat}{bool}{}


\vspace{22pt}
\axiomas{($\forall$ i: interfaz)($\forall$ n: nat)($\forall$ sev:secu(evento))($\forall$ s: secu(regla))($\forall$ c: conj(evento))($\forall$ d: dicc(interfaz,bool))($\forall$ dn: dicc(interfaz,nat))($\forall$ u: dirIP)($\forall$ cv: conj(version))}



\axioma{dirIpDeReglaValida(s,cv)}{if vacia?(s) then true \\
								  else dirIP(prim(s)) $\in$ cv $\wedge$ dirIpDeReglaValida(fin(s),c)}

\axioma{ordenadosPorTimestamp(sev)}{if long(sev) $\leq$ 1 then true\\
									else timestamp(prim(sev)) $<$ timestamp(prim(fin(sev))) \\
									$\wedge$ ordenadosPorTimestamp(fin(sev))}

\axioma{eventosValidos(sev,d,n)}{if n=0? then seCayo?(n,sev) $=$ obtener(n,d) \\
								 else seCayo?(n,sev) $=$ obtener(n,d) $\wedge$ \\
								 eventosValidos(sev,d,n-1)}

\axioma{seCayo?(n,sev)}{if vacia?(sev) then false \\
						else if inter(ult(sev)) $=$ n then caida?(ult(sev)) \\
						else seCayo?(n,com(sev))}
						
\axioma{cantBitsValida(s)}{if vacia?(s) then true \\
						   else cantBitsValida(prim(s)) $\leq$ 8 * version(prim(s)) \\
						   $\wedge$\ cantBitsValida(fin(s))}
						   
\axioma{tiempoCaidaConInterValida(dn,n)}{($\forall$ i : interfaz) ((i $<$ n) $\impluego$ def?(i,dn))}

\axioma{estaCaidaConInterValida(d,n)}{($\forall$ i : interfaz) ((i $<$ n) $\impluego$ def?(i,d))}

%FUNCION DE ABSTRACCION
\subsection*{Funci\'on\ de\ Abstracci\'on}
\alinearfuncs{salidaPorInterfaz}{\hspace{10.6cm}}
\alinearaxiomas{salidaPorInterfaz(s,u)}

\vspace{11pt}
\func{Abs}{estr/e}{enrutador}{Rep(e)}

($\forall$ e: estr) Abs(e) = r: router/ ((versiones(r) $\igobs$\ $\widehat{e.versiones}$) $\wedge$ (interfaces(r) $\igobs$ $\widehat{e.interfaces}$) $\wedge$ ($\forall$ i: interfaz) (eventos(r,i) $\igobs$ filtrarEventos(i,$\widehat{e.eventos}$)) $\yluego$ (($\forall$ d:dirIp) (enrutar(r,d) $\igobs$ aplicarRegla($\widehat{e.reglas}$,$\widehat{e.versiones}$,$\widehat{e.estaCaida}$,d)))

\otrasops
\vspace{33pt}

\func{filtrarEventos}{interfaz,secu(evento)/s}{secu(evento)}{ordenadosPorTimestamp(s)}

\func{aplicarRegla}{secu(regla)/s,conj(version)/v,dicc(interfaz,bool),dirIP}{respuestaDir}{($\forall$ r: regla)(esta?(r,s)) $\impluego$ (version(dirIP(r)) $\in$ v)}

\func{hayRegla}{secu(regla),dirIP}{bool}{}

\func{salidaPorInterfaz}{secu(regla)/s,dirIP/s}{interfaz}{($\exists$ r:regla)(esta?(r,s)\ $\wedge$\ (version(dirIP) = version(r))}

\vspace{22pt}
\axiomas{($\forall$ i: interfaz)($\forall$ sev:secu(evento))($\forall$ s: secu(regla))($\forall$ c: conj(evento))($\forall$ d: dicc(interfaz,bool))($\forall$ u: dirIP)}


\axioma{filtrarEventos(i,sev)}{ if\ vacia?(sev)\ then\ $\secuvacia$\\
else\ if\ (inter(prim(sev)) = i)\ then\\ \hspace*{1cm}filtrarEventos(i,fin(sev)) $\circulito$ prim(sev)\\ else\ filtrarEventos(i,fin(sev))\\fi}

\axioma{aplicarRegla(s,c,d,u)}{ if\ (version(d) $\notin$ c)\ then\\DireccionNoSoportada\\
else\ if\ ($\neg$ hayRegla(s,u))\ then\\ \hspace*{1cm}interfazDeSalidaNoEncontrada\\ else\ if\ obtener(salePorInterfaz(s,u),c)\ then\\ \hspace*{1cm}interfazDeSalidaCaida\\ else\ SalidaPorInterfaz(salePorInterfaz(s,u))\\fi}

\axioma{hayRegla(s,u)}{ if\ vacia?(s)\ then\ false\\ else\ primerosBitsIguales(dirIP(prim(s),u,cantBits(prim(s)))\\ \hspace*{1cm} $\oluego$ hayRegla(fin(s),d))\\fi}

\axioma{salidaPorInterfaz(s,u)}{ if\ vacia?(fin(s))\ then\ inter(prim(s))\\ else\ if\ primerosBitsIguales(dirIP(prim(s)),u,cantBits(prim(s)))\ then\\ \hspace*{1cm}inter(prim(s))\\ else\ salePorInterfaz(fin(s),u)\\fi}

%ALGORITMOS
\subsection*{Algoritmos}