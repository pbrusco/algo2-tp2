\section*{Modulo \nombretad{Router}}

%INTERFAZ	
\subsection*{Interfaz}
\textbf{interfaz} \textit{Router}\\
\textbf{se explica con la especificaci\'on de} \textit{Router}\\
\textbf{usa interfaces} \nombretad{Bool}, \nombretad{Nat}, \nombretad{Conjunto(versi\'on)}, \nombretad{Secuencia(Evento)}, \nombretad{ReglaDir}, \nombretad{RespuestaDir}, \nombretad{Evento}, \nombretad{versi\'on}, \nombretad{DirIp}\\
\textbf{genero} \textit{router}\\
\textbf{operaciones}\\

nuevo(in n: nat)$\rightarrow$ res: router\\
$\{$true$\}$\\
$\{\widehat{res} \igobs$ nuevo($\widehat{n}$)$\}$\\

agversi\'on(inout r: router, in v: versi\'on)\\
$\{$($\widehat{r} \igobs\ r_0$) $\wedge$ ($\widehat{v} \notin$ versiones($\widehat{r}$))$\}$\\
$\{\widehat{r} \igobs$ agVersi\'on($r_0$,$\widehat{v}$)$\}$\\

agRegla(inout r: router, in u: reglaDir)\\
$\{$($\widehat{r} \igobs\ r_0$) $\wedge$ (versi\'on(dirIp($\widehat{u}$)) $\in$ versiones($\widehat{r}$)) $\wedge$ (inter($\widehat{u}$) interfaces($\widehat{r}$))$\}$\\
$\{\widehat{r} \igobs$ agRegla($r_0$,$\widehat{u}$)$\}$\\

agEvento(inout r: router, in e :evento)\\
$\{$($\widehat{r} \igobs\ r_0$) $\wedge$ ($\neg \exists$ i: interfaz)(i $<$ interfaces($\widehat{r}$)) $\wedge_L$ existeTimestamp?(eventos($\widehat{r}$,i),timestam($\widehat{e}$)))$\}$\\
$\{\widehat{r}\igobs$ agEvento($r_0$,$\widehat{e}$)$\}$\\

versiones(in r: router)$\longrightarrow$ res: conj(versi\'on)\\
$\{$true$\}$\\
$\{\widehat{res}\igobs$ versiones($\widehat{r}$)$\}$\\

interfaces(in r: router)$\longrightarrow$ res: nat\\
$\{$true$\}$\\
$\{\widehat{res} \igobs$ interfaces($\widehat{r}$)$\}$\\

enrutar(in r: router, in d: dirIp)$\longrightarrow$ res: respDir\\
$\{$true$\}$\\
$\{\widehat{res} \igobs$ enrutar($\widehat{r}$,$\widehat{d}$)$\}$\\

eventos(in r: router, in i: interfaz)$\longrightarrow$ res: secu(eventos)\\
$\{$true$\}$\\
$\{\widehat{res} \igobs$ eventos($\widehat{r}$,$\widehat{i}$)$\}$\\

estaCaida?(in r: router, in i: interfaz)$\longrightarrow$ res: bool\\
$\{\widehat{i} <$ interfaces($\widehat{r}$)$\}$\\
$\{\widehat{res} \igobs$ estaCaida($\widehat{r}$,$\widehat{i}$)$\}$\\

tiempoCaida(in r: router, in i: interfaz)$\longrightarrow$ res: nat\\
$\{\widehat{i} <$ interfaces($\widehat{r}$)$\}$\\
$\{\widehat{res} \igobs$ tiempocaida($\widehat{r}$,$\widehat{i}$)$\}$\\


%REPRESENTACION
\subsection*{Representaci\'on}
\textit{enrutador} \textbf{se representa con} \textit{estr}\\
\textbf{donde} \textit{estr} \textbf{es} \textit{tupla$ \langle$\ \textbf{cantInterfaces:} nat $\times$ \textbf{versiones:} cto(versi\'on) $\times$  \textbf{eventos:} secu(evento) $\times$ \textbf{reglas:} dicc(dirIp,interfaz) $\times$ \textbf{tiempoCaida:} dicc(interfaz,nat) $\times$ \textbf{estaCaida:} dicc(interfaz,bool) $\rangle$}


%INVARIANTE DE REPRESENTACION
\subsection*{Invariante\ de \ Representaci\'on}
\textbf{\func{Rep}{estr}{bool}{}} 
($\forall$ e:estr)Rep(e) = 
%sobre versiones:
versionesReglasEnVersiones(e)
%sobre Interfaces:
$\wedge$ interfacesDeEventosCorrectas(e)
$\wedge$ interCaidaYTiempoCorrectas(e) 
$\wedge$ interfazDeReglaV\'alida(e.reglas,e.cantInterfaces)
%sobre eventos
$\wedge$ ordenadosPorTimestamp(e.eventos)
$\wedge$ eventosValidos(e.eventos,e.estaCaida,e.cantInterfaces -1)
$\wedge$ tiempoCaidaCorrecto(e)  
%sobre reglas:
$\wedge$ dirIpDeReglaV\'alida(e.reglas,e.versiones)\\

\textbf{funciones auxiliares:} 

\alinearaxiomas{interCaidaYTiempoCorrectas(e)}

\textbf{\func{versionesReglasEnVersiones}{estr}{bool}{}}
\axioma{versionesReglasEnVersiones(e)}{($\forall$ r:regla)esta?(r,e.reglas) $\impluego$ version(dirIp(r)) $\in$ e.versiones}

\textbf{\func{tiempoCaidaCorrecto}{estr}{bool}{}}
\axioma{tiempoCaidaCorrecto(e)}{($\forall$ i:interfaz)( i $\in$ claves(e.tiempoCaida)
 $\impluego$\\ obtener(i,e.tiempoCaida) = \\sumarTiempo(i,filtrarPorInterfaz(i,e.eventos)))}

\textbf{\func{interCaidaYTiempoCorrectas}{estr}{bool}{}}
\axioma{interCaidaYTiempoCorrectas(e)}{(($\forall$ i:interfaz) i $\in$ claves(e.tiempoCaida) $\vee$ i $\in$ claves(e.estaCaida?)   $\impluego$ i $<$ e.cantInterfaces)}

\textbf{\func{ interfazDeReglaV\'alida}{dicc(dirIp,interfaz),nat}{bool}{}}
\axioma{interfazDeReglaV\'alida(dicc,n)}{($\forall d:dirIp$) d $\in$ claves(dicc) $\impluego$ obtener(d,dicc) $<$ n}

\textbf{\func{interfacesDeEventosCorrectas}{estr}{bool}{}}
\axioma{interfacesDeEventosCorrectas(e)}{($\forall$ ev:evento) esta?(ev,e.eventos) $\impluego$ inter(ev) $<$} e.cantInterfaces

\textbf{\func{dirIpDeReglaValida}{dicc(dirIp,interfaz),conj(version)}{bool}{}}
\axioma{dirIpDeReglaValida(dicc,cv)}{($\forall d:dirIp$) d $\in$ claves(dicc) $\impluego$ versi\'on(d) $\in$ cv}

\textbf{\func{ordenadosPorTimestamp}{secu(evento)}{bool}{}}
\axioma{ordenadosPorTimestamp(sev)}{if long(sev) $\leq$ 1 then true\\
									else timestamp(prim(sev)) $<$ timestamp(prim(fin(sev))) \\
									$\wedge$ ordenadosPorTimestamp(fin(sev))}

\textbf{\func{eventosValidos}{secu(evento),dicc(interfaz,bool),nat}{bool}{}}
\axioma{eventosValidos(sev,d,n)}{if n=0? then seCayo?(n,sev) $=$ obtener(n,d) \\
								 else seCayo?(n,sev) $=$ obtener(n,d) $\wedge$ \\
								 eventosValidos(sev,d,n-1)}

\textbf{\func{seCayo?}{nat,secu(evento)}{bool}{}}
\axioma{seCayo?(n,sev)}{if vacia?(sev) then false \\
						else if inter(ult(sev)) $=$ n then caida?(ult(sev)) \\
						else seCayo?(n,com(sev))}

\textbf{\func{cantBitsValida}{secu(regla)}{bool}{}						}
\axioma{cantBitsValida(s)}{if vacia?(s) then true \\
						   else cantBits(prim(s)) $\leq$ 8 * version(prim(s)) \\
						   $\wedge$\ cantBitsValida(fin(s))}

\textbf{\func{filtrarPorInterfaz}{interfaz,secu(evento)}{secu(evento)}{}						}
\axioma{filtrarPorInterfaz(i,s)}{
\LIF { vacia?(s)} \LTHEN{ $<>$} 
\\ \LELSE{  
\LIF{ i = inter(prim(s)} 
\LTHEN{ prim(s) $\puntito$ filtrarPorInterfaz(i,fin(s))} \\ 
\LELSE{ filtrarPorInterfaz(i,fin(s))}} \LFI
}

\textbf{\func{sumarCaidas}{interfaz,secu(evento)}{nat}{}						}
\axioma{sumarCaidas(i,s)}{
\LIF { vacia?(s) $\oluego$ vacia?(fin(s))} \LTHEN{ 0} 
\\ \LELSE{  
\LIF{caida?(fin(s) } 
\LTHEN{ timestamp(prim(fin(s))) - timestamp(prim(s))} \\ 
\LELSE{ 0}} \LFI + sumarCaidas(fin(s))
}


%FUNCION DE ABSTRACCION
\subsection*{Funci\'on\ de\ Abstracci\'on}
\alinearfuncs{Abs}{\hspace{1cm}}
\func{Abs}{estr/e}{enrutador}{Rep(e)}
\vspace{11pt}
($\forall$ e: estr) Abs(e) = r: router/ ((versiones(r) $\igobs$\ $\widehat{e.versiones}$) $\wedge$ (interfaces(r) $\igobs$ $\widehat{e.interfaces}$) $\wedge$ ($\forall$ i: interfaz) (eventos(r,i) $\igobs$ filtrarEventos(i,$\widehat{e.eventos}$)) $\yluego$ (($\forall$ d:dirIp) (enrutar(r,d) $\igobs$ aplicarRegla($\widehat{e.reglas}$,$\widehat{e.versiones}$,$\widehat{e.estaCaida}$,d)))

\vspace{33pt}
\textbf{funciones auxiliares}
\alinearfuncs{salidaPorInterfaz}{\hspace{10.6cm}}
\alinearaxiomas{salidaPorInterfaz(s,u)}

\func{filtrarEventos}{interfaz,secu(evento)/s}{secu(evento)}{ordenadosPorTimestamp(s)}
\axioma{filtrarEventos(i,sev)}{ if\ vacia?(sev)\ then\ $\secuvacia$\\
else\ if\ (inter(prim(sev)) = i)\ then\\ \hspace*{1cm}filtrarEventos(i,fin(sev)) $\circulito$ prim(sev)\\ else\ filtrarEventos(i,fin(sev))\\fi}\\

\func{aplicarRegla}{secu(regla)/s,conj(version)/v,dicc(interfaz,bool),dirIP}{respuestaDir}{($\forall$ r: regla)(esta?(r,s)) $\impluego$ (version(dirIP(r)) $\in$ v)}
\axioma{aplicarRegla(s,c,d,u)}{ if\ (version(d) $\notin$ c)\ then\\DireccionNoSoportada\\ else\ if\ ($\neg$ hayRegla(s,u))\ then\\ \hspace*{1cm}interfazDeSalidaNoEncontrada\\ else\ if\ obtener(salePorInterfaz(s,u),c)\ then\\ \hspace*{1cm}interfazDeSalidaCaida\\ else\ SalidaPorInterfaz(salePorInterfaz(s,u))\\fi}\\

\func{hayRegla}{secu(regla),dirIP}{bool}{}
\axioma{hayRegla(s,u)}{ if\ vacia?(s)\ then\ false\\ else\ primerosBitsIguales(dirIP(prim(s),u,cantBits(prim(s)))\\ \hspace*{1cm} $\oluego$ hayRegla(fin(s),d))\\fi}\\

\func{salidaPorInterfaz}{secu(regla)/s,dirIP/s}{interfaz}{($\exists$ r:regla)(esta?(r,s)\ $\wedge$\ (version(dirIP) = version(r))}
\axioma{salidaPorInterfaz(s,u)}{ if\ vacia?(fin(s))\ then\ inter(prim(s))\\ else\ if\ primerosBitsIguales(dirIP(prim(s)),u,cantBits(prim(s)))\ then\\ \hspace*{1cm}inter(prim(s))\\ else\ salePorInterfaz(fin(s),u)\\fi}


%ALGORITMOS
\subsection*{Algoritmos}
