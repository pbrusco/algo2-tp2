\section*{Modulo \nombretad{Router}}

%INTERFAZ	
\subsection*{Interfaz}
\textbf{interfaz} \textit{Router}\\
\textbf{se explica con la especificaci\'on de} \textit{Router}\\
\textbf{usa interfaces} \nombretad{Bool}, \nombretad{Nat}, \nombretad{Conjunto(versi\'on)}, \nombretad{Secuencia(Evento)}, \nombretad{ReglaDir}, \nombretad{RespuestaDir}, \nombretad{Evento}, \nombretad{versi\'on}, \nombretad{DirIp}\\
\textbf{genero} \textit{router}\\
\textbf{operaciones}\\

nuevo(in n: nat)$\rightarrow$ res: router\\
$\{$true$\}$\\
$\{\sombreritoWide{res} \igobs$ nuevo($\sombreritoWide{n}$)$\}$\\

agVersi\'on(inout r: router, in v: versi\'on)\\
$\{$($\sombreritoWide{r} \igobs\ r_0$) $\wedge$ ($\sombreritoWide{v} \notin$ versiones($\sombreritoWide{r}$))$\}$\\
$\{\sombreritoWide{r} \igobs$ agVersi\'on($r_0$,$\sombreritoWide{v}$)$\}$\\

agRegla(inout r: router, in u: reglaDir)\\
$\{$($\sombreritoWide{r} \igobs\ r_0$) $\wedge$ (versi\'on(dirIp($\sombreritoWide{u}$)) $\in$ versiones($\sombreritoWide{r}$)) $\wedge$ (inter($\sombreritoWide{u}$) interfaces($\sombreritoWide{r}$))$\}$\\
$\{\sombreritoWide{r} \igobs$ agRegla($r_0$,$\sombreritoWide{u}$)$\}$\\

agEvento(inout r: router, in e :evento)\\
$\{$($\sombreritoWide{r} \igobs\ r_0$) $\wedge$ ($\neg \exists$ i: interfaz)(i $<$ interfaces($\sombreritoWide{r}$)) $\wedge_L$ existeTimestamp?(eventos($\sombreritoWide{r}$,i),timestam($\sombreritoWide{e}$)))$\}$\\
$\{\sombreritoWide{r}\igobs$ agEvento($r_0$,$\sombreritoWide{e}$)$\}$\\

versiones(in r: router)$\longrightarrow$ res: conj(versi\'on)\\
$\{$true$\}$\\
$\{\sombreritoWide{res}\igobs$ versiones($\sombreritoWide{r}$)$\}$\\

interfaces(in r: router)$\longrightarrow$ res: nat\\
$\{$true$\}$\\
$\{\sombreritoWide{res} \igobs$ interfaces($\sombreritoWide{r}$)$\}$\\

enrutar(in r: router, in d: dirIp)$\longrightarrow$ res: respDir\\
$\{$true$\}$\\
$\{\sombreritoWide{res} \igobs$ enrutar($\sombreritoWide{r}$,$\sombreritoWide{d}$)$\}$\\

eventos(in r: router, in i: interfaz)$\longrightarrow$ res: secuOrdSinRep(eventos)\\
$\{$true$\}$\\
$\{\sombreritoWide{res} \igobs$ eventos($\sombreritoWide{r}$,$\sombreritoWide{i}$)$\}$\\

estaCaida?(in r: router, in i: interfaz)$\longrightarrow$ res: bool\\
$\{\sombreritoWide{i} <$ interfaces($\sombreritoWide{r}$)$\}$\\
$\{\sombreritoWide{res} \igobs$ estaCaida($\sombreritoWide{r}$,$\sombreritoWide{i}$)$\}$\\

tiempoCaida(in r: router, in i: interfaz)$\longrightarrow$ res: nat\\
$\{\sombreritoWide{i} <$ interfaces($\sombreritoWide{r}$)$\}$\\
$\{\sombreritoWide{res} \igobs$ tiempocaida($\sombreritoWide{r}$,$\sombreritoWide{i}$)$\}$\\


%REPRESENTACION
\subsection*{Representaci\'on}
\textit{enrutador} \textbf{se representa con} \textit{estr}\\
\textbf{donde} \textit{estr} \textbf{es} \textit{tupla $\langle$ versiones: conj(versi\'on)\\
\hspace*{3.5cm} $\times$  cantInterfaces: nat\\
\hspace*{3.5cm} $\times$  reglas: secuOrdSinRep(tupla$\langle$version: version, aR: arbolDeReglas$\rangle$)\\ %aca hay que decir como se ordena
\hspace*{3.5cm} $\times$  status-inter: ad(tupla$\langle$tiempoCaida: nat, eventos: secuOrdSinRep(evento)$\rangle$) $\rangle$}


%INVARIANTE DE REPRESENTACION
\subsection*{Invariante\ de \ Representaci\'on}
\textbf{\func{Rep}{estr}{bool}{}} 
($\forall$ e:estr)Rep(e) = \\
versionesDeReglasValidas(e.reglas, e.versiones) $\wedge$ \\
interfacesDeArbolesValidas(e.reglas, e.cantInterfaces) $\wedge$ \\
longitudDeEventosValida(e.status-inter, e.cantInterfaces) \yluego \\ %aca ya se que se puede hacer de una pero queda mas declarativo asi
interfazDeEventosCorrecta(e.cantInterfaces, e.status-inter) \yluego \\
tiempoCaidaValido(e.status-inter)\\

\textbf{funciones auxiliares:} 

\alinearaxiomas{interfacesDeArbolesValidas(s,n)}
\alinearfuncs{interfacesDeArbolesValidasLA}{\hspace{7.4cm}}

\textbf{\func{versionesDeReglasValidas}{secuOrdSinRep(tupla(version,abr)),cto(version)}{bool}{}}
\axioma{versionesDeReglasValidas(s,c)}{\lif vacia?(s) \lthen \true\\
										\hspace*{-0.85cm}\lelse $\Pi_1$(prim(s)) $\in$ c $\wedge$ versionesDeReglasValidas(fin(s),c)}

\textbf{\func{interfacesDeArbolesValidas}{secuOrdSinRep(tupla(version,abr)),nat}{bool}{}}
\axioma{interfacesDeArbolesValidas(s,n)}{($\forall$ d: dirIp) (estaVersionEnTupla(d,s) \impluego \\
											interValidasAux(s,n,d))}

\textbf{\func{estaVersionEnTupla}{dirIp,secuOrdSinRep(tupla(version,abr))}{bool}{}}
\axioma{estaVersionEnTupla(d,s)}{\lif vacia?(s) \lthen \false\\
								\hspace*{-0.85cm}\lelse $\Pi_1$(prim(s)) $=$ version(d) $\vee$ estaVersionEnTupla(d,fin(s))}

\textbf{\func{interValidasAux}{secuOrdSinRep(tupla(version,abr))/s,nat,dirIp/d}{bool}{estaVersionEnTupla(d,s)}}
\axioma{interValidasAux(s,n,d)}{\lif $\Pi_1$(prim(s)) $=$ version(d) \\
								\hspace*{0.6cm}\lthen interfazDeSalida($\Pi_2$(prim(s)),d) $<$ n\\
								\hspace*{-0.85cm}\lelse interValidasAux(fin(s),n,d)}

\textbf{\func{interfazDeEventosCorrecta}{nat,ad(tupla(nat,secuOrdSinRep(evento)))}{bool}{}}
\axioma{interfazDeEventosCorrecta(n,a)}{($\forall$ i:interfaz) (i $<$ n \impluego\ 		sonEventosDeLaInterfaz($\Pi_2$(a[i]),i))}

\textbf{\func{sonEventosDeLaInterfaz}{secuOrdSinRep(evento),interfaz}{bool}{}}
\axioma{sonEventosDeLaInterfaz(s,i)}{\lif vacia?(s) \lthen \true \\
									\hspace*{-0.85cm}\lelse inter(prim(s)) $=$ i $\wedge$ sonEventosDeLaInterfaz(fin(s),i)}

\textbf{\func{tiempoCaidaValido}{ad(tupla(nat,secu(evento)))}{bool}{}}
\axioma{tiempoCaidaValido(a)}{($\forall$ i:interfaz) (i $<$ n \impluego\ $\Pi_1$(a[i]) $=$ sumarCaidas($\Pi_2$(a[i]))}

\textbf{\func{sumarCaidas}{secuOrdSinRep(evento)}{nat}{}}
\axioma{sumarCaidas(s)}{\lif vacia?(s) \oluego vacia?(fin(s)) \lthen 0 \\ 
						\hspace*{-0.85cm}\lelse \lif caida?(ult(s)) \\
						\hspace*{1cm}\lthen timestamp(ult(com(s))) - timestamp(ult(s)) + sumarCaidas(com(s)) \\ 
						\hspace*{-0.85cm}\lelse sumarCaidas(com(s))}

\textbf{\func{longitudDeEventosValida}{ad(tupla(nat,secuOrdSinRep(evento))),nat}{bool}{}}
\axioma{longitudDeEventosValida(a,n)}{tam(a) = n}



%FUNCION DE ABSTRACCION
\subsection*{Funci\'on\ de\ Abstracci\'on}
\alinearfuncs{Abs}{\hspace{1cm}}
\func{Abs}{estr/e}{enrutador}{Rep(e)}
\vspace{11pt}
($\forall$ e: estr) Abs(e) = r: router/ \\
versiones(r) \igobs e.versiones $\wedge$ interfaces(r) \igobs e.cantInterfaces \yluego \\
($\forall$ i: interfaz)(i $<$ interfaces(r) \impluego reverso(eventos(r,i)) \igobs $\Pi_2$(e.status-inter[i])) $\wedge$ \\
($\forall$ d: dirIp)(enrutar(r,d) \igobs dameRtaDir(e,d))\\

\vspace{33pt}
\textbf{funciones auxiliares}
\alinearfuncs{arbolDeLaVersionLA}{\hspace{8cm}}
\alinearaxiomas{arbolDeLaVersion(v,s)}

\textbf{\func{dameRtaDir}{estr,dirIp}{respuestaDir}{Rep(e)}}
\axioma{dameRtaDir(e,d)}{\lif version(d) $\in$ e.versiones \lthen DireccionNoSoportada \\
						 \hspace*{-0.85cm}\lelse \lif $\neg$tieneRegla(arbolDeLaVersion(version(d),e.reglas),d) \\
						 \hspace*{0.6cm}\lthen interfazDeSalidaNoEncontrada \\
						 \hspace*{-0.85cm}\lelse \lif estaCaida?(prim($\Pi_2$(e.status-inter[queInterfaz(e,d)]))) \\
						 \hspace*{0.6cm}\lthen interfazDeSalidaCaida(queInterfaz(e,d)) \\
						 \hspace*{-0.85cm}\lelse SalidaPorInterfaz(queInterfaz(e,d))}
						 
\textbf{\func{queInterfaz}{estr,dirIp}{interfaz}{Rep(e)}}				 
\axioma{queInterfaz(e,d)}{interfazDeSalida(arbolDeLaVersion(version(d),e.reglas),d)}

\textbf{\func{arbolDeLaVersion}{version/v,secu(tupla(version,abr))/s}{abr}{}}	
\axioma{arbolDeLaVersion(v,s)}{\lif vacia?(s) then nuevo() \\
				\hspace*{-0.85cm}\lelse \lif $\Pi_1$(prim(s)) $=$ v then $\Pi_2$(prim(s))\\
							  \hspace*{-0.85cm}\lelse arbolDeLaVersion(v,fin(s))}
		

%ALGORITMOS
\subsection*{Algoritmos}


\incmargin{1em}
\linesnumbered
\restylealgo{boxed}
\dontprintsemicolon
\textit{i}nuevo(in n: nat) $\longrightarrow$ res: estr \\
\SetKw{Orden}{Complejidad:}

\begin{algorithm}[H]
\Orden{O(n)}
\BlankLine
\textbf{var} inter: arreglo\_dimensionable de tupla$\langle$nat, secuOrdSinRep(evento)$\rangle$ \\
\BlankLine
inter $\leftarrow$ CrearArreglo(n)\tcp*{O(n)}
\BlankLine
\For{(i: nat $\leftarrow$ 0, i $<$ n) \tcp*{O(n)}}{ 
inter[i] $\leftarrow$ $\langle$0, $<>\rangle$\tcp*{O(1)}
i $\leftarrow$ (i+1)\tcp*{O(1)}}
\BlankLine
res $\leftarrow \langle \emptyset$, n, $<>$, inter$\rangle$\tcp*{O(1)}
\end{algorithm}

\vspace{11pt}

\textit{i}agVersion(inout e: estr, in v: version)\\
\begin{algorithm}[H]
\Orden{O(v)}
\BlankLine
agregar(v, e.versiones)\tcp*{O(v)}
insertar($\langle$v, $<>\rangle$, e.reglas)\tcp*{O(v)}
\end{algorithm}

\vspace{11pt}

\textit{i}agRegla(inout e: estr, in u: reglaDir)\\
\begin{algorithm}[H]
\Orden{O(version(dirIp(u)))}
\BlankLine
\textbf{var} it: itOrd(secuOrdSinRep(tupla $\langle$version, arbolDeReglas$\rangle$))\\
\textbf{var} v: version\\
\BlankLine
it $\leftarrow$ crearIt(e.reglas) \tcp*{O(1)}
v  $\leftarrow$ u.version \tcp*{O(1)}
\BlankLine
\While{(actual(it).version $\neq$ v) \tcp*{O(version(dirIp(u))))}}
{avanzar(it)}
agRegla(actual(it).aR, v) \tcp*{O(cantBits(u))}
\end{algorithm}

\vspace{11pt}

\textit{i}agEvento(inout e: estr, in m: evento)\\
\begin{algorithm}[H]
\Orden{O(a)}
\BlankLine

FALTA
\end{algorithm}

\vspace{11pt}

\textit{i}versiones(in e: estr) $\longrightarrow$ res: conj(version)\\
\begin{algorithm}[H]
\Orden{O(1)}
\BlankLine
res $\leftarrow$ e.versiones\tcp*{O(1)}
\end{algorithm}

\vspace{11pt}


\textit{i}interfaces(in e: estr) $\longrightarrow$ res: nat\\
\begin{algorithm}[H]
\Orden{O(1)}
\BlankLine
res $\leftarrow$ e.cantInterfaces \tcp*{O(1)}
\end{algorithm}

\vspace{11pt}

\textit{i}enrutar(inout e: estr, in d: dirIp)\\
\begin{algorithm}[H]
\Orden{O(version(d))}
\BlankLine
ME FALTA HACERLO
\end{algorithm}


\textit{i}eventos(in e: estr, in i: interfaz) $\longrightarrow$ res: secuOrdSinRep(evento)\\
\begin{algorithm}[H]
\Orden{O(1)}
\BlankLine
res $\leftarrow$ (e.status-inter[i]).eventos\tcp*{O(1)}
\end{algorithm}



\textit{i}estaCaida?(in e: estr, in i: interfaz) $\longrightarrow$ res: bool\\
\begin{algorithm}[H]
\Orden{O(1)}
\BlankLine
\textbf{var} it: itOrd(secuOrdSinRep(tupla $\langle$nat, evento$\rangle$)) \\
\BlankLine
it $\leftarrow$ crearIt((e.status-inter[i]).eventos) \tcp*{O(1)}
\BlankLine
res $\rightarrow$ actual(it).estaCaida? \tcp*{O(1)}
\end{algorithm}

\vspace{11pt}

\textit{i}tiempoCaida(in e: estr, in i: interfaz) $\longrightarrow$ res: nat \\
\begin{algorithm}[H]
\Orden{O(1)}
\BlankLine

res $\leftarrow$ (e.status-inter[i]).tiempoCaida \tcp*{O(1)}
\end{algorithm}

\vspace{11pt}

