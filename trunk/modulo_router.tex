\section*{Modulo \nombretad{Router}}

%INTERFAZ	
\subsection*{Interfaz}
\textbf{interfaz} \textit{Router}\\
\textbf{se explica con la especificaci\'on de} \textit{Router}\\
\textbf{usa interfaces} \nombretad{Bool}, \nombretad{Nat}, \nombretad{Conjunto(versi\'on)}, \nombretad{Secuencia(Evento)}, \nombretad{ReglaDir}, \nombretad{RespuestaDir}, \nombretad{Evento}, \nombretad{versi\'on}, \nombretad{DirIp}\\
\textbf{genero} \textit{router}\\
\textbf{operaciones}\\

nuevo(in n: nat)$\rightarrow$ res: router\\
$\{$true$\}$\\
$\{\widehat{res} \igobs$ nuevo($\widehat{n}$)$\}$\\

agVersi\'on(inout r: router, in v: versi\'on)\\
$\{$($\widehat{r} \igobs\ r_0$) $\wedge$ ($\widehat{v} \notin$ versiones($\widehat{r}$))$\}$\\
$\{\widehat{r} \igobs$ agVersi\'on($r_0$,$\widehat{v}$)$\}$\\

agRegla(inout r: router, in u: reglaDir)\\
$\{$($\widehat{r} \igobs\ r_0$) $\wedge$ (versi\'on(dirIp($\widehat{u}$)) $\in$ versiones($\widehat{r}$)) $\wedge$ (inter($\widehat{u}$) interfaces($\widehat{r}$))$\}$\\
$\{\widehat{r} \igobs$ agRegla($r_0$,$\widehat{u}$)$\}$\\

agEvento(inout r: router, in e :evento)\\
$\{$($\widehat{r} \igobs\ r_0$) $\wedge$ ($\neg \exists$ i: interfaz)(i $<$ interfaces($\widehat{r}$)) $\wedge_L$ existeTimestamp?(eventos($\widehat{r}$,i),timestam($\widehat{e}$)))$\}$\\
$\{\widehat{r}\igobs$ agEvento($r_0$,$\widehat{e}$)$\}$\\

versiones(in r: router)$\longrightarrow$ res: conj(versi\'on)\\
$\{$true$\}$\\
$\{\widehat{res}\igobs$ versiones($\widehat{r}$)$\}$\\

interfaces(in r: router)$\longrightarrow$ res: nat\\
$\{$true$\}$\\
$\{\widehat{res} \igobs$ interfaces($\widehat{r}$)$\}$\\

enrutar(in r: router, in d: dirIp)$\longrightarrow$ res: respDir\\
$\{$true$\}$\\
$\{\widehat{res} \igobs$ enrutar($\widehat{r}$,$\widehat{d}$)$\}$\\

eventos(in r: router, in i: interfaz)$\longrightarrow$ res: secuOrdSinRep(eventos)\\
$\{$true$\}$\\
$\{\widehat{res} \igobs$ eventos($\widehat{r}$,$\widehat{i}$)$\}$\\

estaCaida?(in r: router, in i: interfaz)$\longrightarrow$ res: bool\\
$\{\widehat{i} <$ interfaces($\widehat{r}$)$\}$\\
$\{\widehat{res} \igobs$ estaCaida($\widehat{r}$,$\widehat{i}$)$\}$\\

tiempoCaida(in r: router, in i: interfaz)$\longrightarrow$ res: nat\\
$\{\widehat{i} <$ interfaces($\widehat{r}$)$\}$\\
$\{\widehat{res} \igobs$ tiempocaida($\widehat{r}$,$\widehat{i}$)$\}$\\


%REPRESENTACION
\subsection*{Representaci\'on}
\textit{enrutador} \textbf{se representa con} \textit{estr}\\
\textbf{donde} \textit{estr} \textbf{es} \textit{tupla $\langle$ versiones: conj(versi\'on)\\
\hspace*{3.5cm} $\times$  cantInterfaces: nat\\
\hspace*{3.5cm} $\times$  reglas: secuOrdSinRep(tupla$\langle$version: version, aR: arbolDeReglas$\rangle$)\\ %aca hay que decir como se ordena
\hspace*{3.5cm} $\times$  status-inter: ad(tupla$\langle$tiempoCaida: nat, eventos: secuOrdSinRep(evento)$\rangle$) $\rangle$}


%INVARIANTE DE REPRESENTACION
\subsection*{Invariante\ de \ Representaci\'on}
\textbf{\func{Rep}{estr}{bool}{}} 
($\forall$ e:estr)Rep(e) = \\
versionesDeReglasValidas(e.reglas, e.versiones) $\wedge$ \\
interfacesDeArbolesValidas(e.reglas, e.cantInterfaces) $\wedge$ \\
longitudDeEventosValida(e.status-inter, e.cantInterfaces) \yluego \\ %aca ya se que se puede hacer de una pero queda mas declarativo asi
interfazDeEventosCorrecta(e.cantInterfaces, e.status-inter) \yluego \\
tiempoCaidaValido(e.status-inter)\\

\textbf{funciones auxiliares:} 

\alinearaxiomas{interfacesDeArbolesValidas(s,n)}
\alinearfuncs{interfacesDeArbolesValidasLA}{\hspace{7.4cm}}

\textbf{\func{versionesDeReglasValidas}{secu(tupla(nat,abr)),cto(version)}{bool}{}}
\axioma{versionesDeReglasValidas(s,c)}{\lif vacia?(s) \lthen \true\\
										\hspace*{-0.85cm}\lelse $\Pi_1$(prim(s)) $\in$ c $\wedge$ versionesDeReglasValidas(fin(s),c)}

\textbf{\func{interfacesDeArbolesValidas}{secu(tupla(nat,abr)),nat}{bool}{}}
\axioma{interfacesDeArbolesValidas(s,n)}{($\forall$ d: dirIp) (estaVersionEnTupla(d,s) \impluego \\
											interValidasAux(s,n,d))}

\textbf{\func{estaVersionEnTupla}{dirIp,secu(tupla(nat,abr))}{bool}{}}
\axioma{estaVersionEnTupla(d,s)}{\lif vacia?(s) \lthen \false\\
								\hspace*{-0.85cm}\lelse $\Pi_1$(prim(s)) $=$ version(d) $\vee$ estaVersionEnTupla(d,fin(s))}

\textbf{\func{interValidasAux}{secu(tupla(nat,abr)),nat,dirIp}{bool}{}}
\axioma{interValidasAux(s,n,d)}{\lif $\Pi_1$(prim(s)) $=$ version(d) \\
								\hspace*{0.6cm}\lthen interfazDeSalida($\Pi_2$(prim(s)),d) $<$ n\\
								\hspace*{-0.85cm}\lelse interValidasAux(fin(s),n,d)}

\textbf{\func{interfazDeEventosCorrecta}{nat,ad(tupla(nat,secu(evento)))}{bool}{}}
\axioma{interfazDeEventosCorrecta(n,a)}{($\forall$ i:interfaz) (i $<$ n \impluego\ 		sonEventosDeLaInterfaz($\Pi_2$(a[i]),i))}

\textbf{\func{sonEventosDeLaInterfaz}{secu(evento),interfaz}{bool}{}}
\axioma{sonEventosDeLaInterfaz(s,i)}{\lif vacia?(s) \lthen \true \\
									\hspace*{-0.85cm}\lelse inter(prim(s)) $=$ i $\wedge$ sonEventosDeLaInterfaz(fin(s),i)}

\textbf{\func{tiempoCaidaValido}{ad(tupla(nat,secu(evento)))}{bool}{}}
\axioma{tiempoCaidaValido(a)}{($\forall$ i:interfaz) (i $<$ n \impluego\ $\Pi_1$(a[i]) $=$ sumarCaidas($\Pi_2$(a[i]))}

\textbf{\func{sumarCaidas}{secu(evento)}{nat}{}}
\axioma{sumarCaidas(s)}{\lif vacia?(s) \oluego vacia?(fin(s)) \lthen 0 \\ 
						\hspace*{-0.85cm}\lelse \lif caida?(ult(s)) \\
						\hspace*{1cm}\lthen timestamp(ult(com(s))) - timestamp(ult(s)) + sumarCaidas(com(s)) \\ 
						\hspace*{-0.85cm}\lelse sumarCaidas(com(s))}

\textbf{\func{longitudDeEventosValida}{ad(tupla(nat,secu(evento))),nat}{bool}{}}
\axioma{longitudDeEventosValida(a,n)}{tam(a) = n}



%FUNCION DE ABSTRACCION
\subsection*{Funci\'on\ de\ Abstracci\'on}
\alinearfuncs{Abs}{\hspace{1cm}}
\func{Abs}{estr/e}{enrutador}{Rep(e)}
\vspace{11pt}
($\forall$ e: estr) Abs(e) = r: router/ \\
versiones(r) \igobs e.versiones $\wedge$ interfaces(r) \igobs e.cantInterfaces \yluego \\
($\forall$ i: interfaz)(i $<$ interfaces(r) \impluego reverso(eventos(r)) \igobs $\Pi_2$(e.status-inter[i])) $\wedge$ \\
($\forall$ d: dirIp)(enrutar(r,d) \igobs dameRtaDir(e,d))\\

\vspace{33pt}
\textbf{funciones auxiliares}
\alinearfuncs{arbolDeLaVersionLA}{\hspace{8cm}}
\alinearaxiomas{arbolDeLaVersion(v,s)}

\textbf{\func{dameRtaDir}{estr,dirIp}{respuestaDir}{Rep(e)}}
\axioma{dameRtaDir(e,d)}{\lif version(d) $\in$ e.versiones \lthen DireccionNoSoportada \\
						 \hspace*{-0.85cm}\lelse \lif $\neg$tieneRegla(arbolDeLaVersion(version(d),e.reglas),d) \\
						 \hspace*{0.6cm}\lthen interfazDeSalidaNoEncontrada \\
						 \hspace*{-0.85cm}\lelse \lif estaCaida?(prim($\Pi_2$(e.status-inter[queInterfaz(e,d)]))) \\
						 \hspace*{0.6cm}\lthen interfazDeSalidaCaida(queInterfaz(e,d)) \\
						 \hspace*{-0.85cm}\lelse SalidaPorInterfaz(queInterfaz(e,d))}
						 
\textbf{\func{queInterfaz}{estr,dirIp}{interfaz}{Rep(e)}}				 
\axioma{queInterfaz(e,d)}{interfazDeSalida(arbolDeLaVersion(version(d),e.reglas),d)}

\textbf{\func{arbolDeLaVersion}{version/v,secu(tupla(version,abr))/s}{abr}{existeVersion(v,s)}}	
\axioma{arbolDeLaVersion(v,s)}{\lif $\Pi_1$(prim(s)) $=$ v then $\Pi_2$(prim(s))\\
							   \hspace*{-0.85cm}\lelse arbolDeLaVersion(v,fin(s))}
							  
\textbf{\func{existeVersion}{version,secu(tupla(version,abr))}{bool}{}}
\axioma{existeVersion(v,s)}{\lif vacia?(s) then \false\\
							\hspace*{-0.85cm}\lelse $\Pi_1$(prim(s)) $=$ v $\vee$ existeVersion(v,fin(s))}


%ALGORITMOS
\subsection*{Algoritmos}

\textit{i}nuevo(in n: nat) $\longrightarrow$ res: estr\\
\begin{algorithm}[H]
\BlankLine
inter: ad(tupla(nat, secuOrdSinRep(evento)) $\leftarrow$ CrearArreglo(n)
\BlankLine
\For{(i: nat $\leftarrow$ 0, i $<$ n}{
inter[i] $\leftarrow$ $\langle$0, $<>\rangle$\\
i $\leftarrow$ (i+1)}
\BlankLine
res $\leftarrow \langle \emptyset$, n, $<>$, inter$\rangle$
\end{algorithm}

\vspace{11pt}

\textit{i}agVersion(inout e: estr, in v: version)\\
\begin{algorithm}[H]
\BlankLine
agregar(v, e.versiones)
\BlankLine
insertar($\langle$v, $<>\rangle$, e.reglas)
\end{algorithm}

\vspace{11pt}

\textit{i}agRegla(inout e: estr, in u: reglaDir)\\
\begin{algorithm}[H]
\BlankLine
it: itOrd(secuOrdSinRep(tupla $\langle$version, arbolDeReglas$\rangle$)) $\leftarrow$ crearIt(e.reglas) 
\BlankLine
v: version $\leftarrow$ u.version
\BlankLine
\While{(actual(it).version $\neq$ v)}{avanzar(it)}
\BlankLine
agRegla(actual(it).aR, v)
\end{algorithm}

\vspace{11pt}

\textit{i}agEvento(inout e: estr, in m: evento)\\
\begin{algorithm}[H]
ME FALTA HACERLO
\end{algorithm}

\vspace{11pt}

\textit{i}versiones(in e: estr) $\longrightarrow$ res: conj(version)\\
\begin{algorithm}[H]
\BlankLine
res $\leftarrow$ e.versiones
\end{algorithm}

\vspace{11pt}

\textit{i}interfaces(in e: estr) $\longrightarrow$ res: nat\\
\begin{algorithm}[H]
\BlankLine
res $\leftarrow$ e.interfaces
\end{algorithm}

\vspace{11pt}

\textit{i}enrutar(inout e: estr, in d: dirIp)\\
\begin{algorithm}[H]
\BlankLine
ME FALTA HACERLO
\end{algorithm}

\vspace{11pt}

\textit{i}eventos(in e: estr, in i: interfaz) $\longrightarrow$ res: secuOrdSinRep(evento)\\
\begin{algorithm}[H]
\BlankLine
res $\leftarrow$ (e.status-inter[i]).eventos
\end{algorithm}

\vspace{11pt}

\textit{i}estaCaida?(in e: estr, in i: interfaz) $\longrightarrow$ res: bool\\
\begin{algorithm}[H]
\BlankLine
it: itOrd(secuOrdSinRep(tupla $\langle$nat, evento$\rangle$)) $\leftarrow$ crearIt((e.status-inter[i]).eventos) 
\BlankLine
res $\rightarrow$ actual(it).estaCaida?
\end{algorithm}

\vspace{11pt}

\textit{i}tiempoCaida(in e: estr, in i: interfaz) $\longrightarrow$ res: nat\\
\begin{algorithm}[H]
res $\leftarrow$ (e.status-inter[i]).tiempoCaida
\end{algorithm}

\vspace{11pt}

